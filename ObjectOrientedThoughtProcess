Procedural programming is generally started for typical software developers 
this involves splitting a program into a number of functions (subroutines or procedures)

You pass data into functions each which perfroms one or more computations and typically pass 
results back

OOP is different, allows programmers to think different about how to build software.
OOP gives programmers a way to combines code and data together into cohesive units, thereby avoiding 
some compilcations of procedural programming

Procedural way of handling object oriented target problem
you have to use global varialbe

def turnOn():
    global switchIsOn
    # turn the light on
    switchIsOn = True

2 def turnOff():
    global switchIsOn
    # turn the light off
    switchIsOn = False
    
# Main code
3 switchIsOn = False  # a global Boolean variable

# Test code
print(switchIsOn)
turnOn()
print(switchIsOn)
turnOff()

Class: code that defines what an object will remember (its data or state) and the things that will be able to do(its functions or behaviour)

#handling the above problem in OOP mod

class LightSwitch():
    def __init__(self):
        self.switchIsOn = False

    def turnOn(self):
        # turn the switch on 
        self.switchIsOn = True

    def turnOff(self):
        # turn the switch off
        self.switchIsOn = False


###################################
you have to tell explicilty tel python to make an object from the class
##########################
Basic form of a class
class <ClassName>():

    def __init__(self, <optional param1>, ..., <optional paramN>):
        #  any initialization code here

    # Any number of functions that access the data
    # Each has the form:

    def <functionName1>(self, <optional param1>, ..., <optional paramN>):
        #  body of function

    #  ... more functions

    def <functionNameN>(self, <optional param1>, ..., <optional paramN>):
        #  body of function
######################################